#!/usr/bin/env perl

# Copyright © 2019-2021 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

no lib '.';  # CVE-2016-1238

use strict;
use warnings;
use v5.14;

use English qw(-no_match_vars);
use HTTP::Tiny;
use JSON::PP;
use Time::Piece;

use HTTP::CookieJar;

my $prog = $PROGRAM_NAME =~ s{.*/}{}r;

my $cookie_jar = HTTP::CookieJar->new;
my %http_options = (
    agent => 'pacz (https://github.com/jwilk/pacz)',
    cookie_jar => $cookie_jar,
    verify_SSL => 1,
);
my $http = HTTP::Tiny->new(%http_options);

my $jp = JSON::PP->new->utf8->pretty;

sub useca
{
    my ($ca) = @_;
    my $cadir = '/usr/share/ca-certificates/mozilla';
    my $cafile = "$cadir/$ca.crt";
    if (-d $cadir) {
        $http = HTTP::Tiny->new(
            %http_options,
            SSL_options => {SSL_ca_file => $cafile}
        );
    }
    return;
}

sub xurlget
{
    my ($url, $data, $args) = @_;
    my $response;
    if (defined $data) {
        if (ref $data eq '') {
            $args = {
                %{$args // {}},
                content => $data,
            };
            $response = $http->post($url, $args);
        } else {
            $response = $http->post_form($url, $data, $args // {});
        }
    } else {
        $response = $http->get($url, $args // {});
    }
    if (not $response->{success}) {
        if ($response->{status} == 599) {
            die "<$url>: $response->{content}";
        } else {
            die "<$url>: $response->{status} $response->{reason}";
        }
    }
    return $response;
}

sub urlget
{
    my @args = @_;
    my $response = xurlget(@args);
    return $response->{content};
}

sub dump_yaml
{
    local ($_) = @_;
    my $use_yaml = 1;
    eval {
        require YAML::XS;
    } or do {
        $use_yaml = 0;
    };
    if ($use_yaml) {
        no warnings 'once';  ## no critic (ProhibitNoWarnings)
        local $YAML::XS::Boolean = 'JSON::PP';
        $_ = YAML::XS::Dump($_);
        s/^---\n//;
    } else {
        $_ = $jp->encode($_);
    }
    print;
    return;
}

sub fatal
{
    my ($msg) = @_;
    say {*STDERR} "pacz: $msg";
    exit 1;
}

sub carrier::allegro
{
    my ($ident) = @_;
    my $x = qr/[0-9a-f]/;
    my ($order_uuid) = ($ident =~ m/\b(${x}{8}-${x}{4}-${x}{4}-${x}{4}-${x}{12})\b/) or
        fatal('allegro: missing order UUID');
    $x = qr/[0-9A-F]/;
    my ($tracking_id) = ($ident =~ m/\b(ALE${x}{12})\b/) or
        fatal('allegro: missing tracking ID');
    useca('DigiCert_Global_Root_CA');
    $http->agent('Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0');
    $http->default_headers({
        'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language' => 'en-US,en;q=0.5',
        'Upgrade-Insecure-Requests' => '1',
    });
    my $url = "https://allegro.pl/przesylka/sledzenie/${order_uuid}?waybillId=${tracking_id}&carrierId=ALLEGRO";
    my $html = urlget($url);
    while ($html =~ m{<section\b[^>]*>(.*?)</section>}g) {
        $_ = $1;
        s{</?div\b[^>]*>}{\n}g;
        s{</?ol\b[^>]*>}{\n}g;
        s{<br\b[^>]*>}{\n}g;
        s{</?span\b[^>]*>}{}g;
        s{</?(?:p)\b[^>]*>}{ | }g;
        s{<li\b[^>]*>(.*?)</li>}{• $1\n}g;
        s{• \K [|] }{}g;
        s{ [|] *[|] }{ | }g;
        s{ *[|] *$}{}mg;
        s{^ *[|] *}{}mg;
        s{^\n+}{};
        s{\n+\z}{};
        s{\n\n+}{\n}g;
        say;
        say '';
    }
    return;
}

sub carrier::dpd
{
    my ($ident) = @_;
    $ident =~ /\A[[:alnum:]]+\z/a or
        fatal('dpd: bad ID format');
    useca('Certum_Trusted_Network_CA');
    my $url = 'https://tracktrace.dpd.com.pl/findPackage';
    $_ = urlget($url, ['q', $ident, 'typ', 1]);
    m{<table class="table-track">(.*?)</table>}s or die;
    $_ = $1;
    s{<thead>(?:.*?)</thead>}{}s;
    s{\s*</?tbody>\s*}{}g;
    s{\s*</t[dr]>\s*}{}g;
    s{\s*<td>}{\t}g;
    s{\s*<tr\b[^>]*>\t}{\n}g;
    s{\s*<br>}{; }g;
    s{&nbsp;}{ }g;
    s{\A\n+}{};
    say;
    return;
}

sub decode_entities  ## no critic (RequireArgUnpacking)
{
    for my $s (@_) {
        $s =~ s/&#([0-9]+);/chr($1)/eg;
    }
    return;
}

sub carrier::gls
{
    my ($ident) = @_;
    $ident =~ /\A\d+\z/a or
        fatal('gls: bad ID format');
    useca('GlobalSign_Root_CA_-_R3');
    my $uts = Time::Piece->new->epoch;
    my $ts = "${uts}000";
    my $url = "https://gls-group.eu/app/service/open/rest/PL/pl/rstt001?match=$ident&millis=$ts";
    my $data = urlget($url);
    $data = $jp->decode($data);
    $data = $data->{tuStatus}->[0];
    delete $data->{progressBar};
    for my $history (@{$data->{history}}) {
        decode_entities($history->{evtDscr});
    }
    my $arrival = $data->{arrivalTime};
    decode_entities(
        $arrival->{name},
        $arrival->{value},
    );
    dump_yaml($data);
    return;
}

sub carrier::inpost
{
    my ($ident) = @_;
    $ident =~ /\A\d+\z/a or
        fatal('inpost: bad ID format');
    useca('DigiCert_Global_Root_CA');
    my $url = "https://api-shipx-pl.easypack24.net/v1/tracking/$ident";
    my $data = urlget($url);
    $data =~ s/\\u0026amp;/&/g;
    $data = $jp->decode($data);
    for my $item (@{$data->{tracking_details}}) {
        if (not defined $item->{agency}) {
            delete $item->{agency};
        }
    }
    if (not defined $data->{custom_attributes}) {
        delete $data->{custom_attributes};
    }
    if (ref $data->{expected_flow} eq 'ARRAY' and scalar @{$data->{expected_flow}} == 0) {
        delete $data->{expected_flow};
    }
    dump_yaml($data);
    return;
}

sub carrier::orlen
{
    my ($ident) = @_;
    $ident =~ /\A\d+\z/a or
        fatal('orlen: bad ID format');
    useca('Certum_Trusted_Network_CA');
    my $uts = Time::Piece->new->epoch;
    my $ts = "${uts}000";
    my $url = "https://nadaj.orlenpaczka.pl/parcel/api-status?id=$ident&jsonp=callback&_=$ts";
    my $data = urlget($url);
    $data =~ s/^callback[(]|[)];$//g;
    $data = $jp->decode($data);
    delete $data->{historyHtml};
    delete $data->{full};
    my $number = $data->{number};
    if (%{$data->{xml}} == 0) {
        delete $data->{xml};
    } else {
        for my $item (@{$data->{xml}->{NewDataSet}->{PackStatus}}) {
            for my $key (qw(Destination City StreetName Location OpeningHours)) {
                $data->{$key} = $item->{$key};
                delete $item->{$key};
            }
            for my $key (qw(Attribute Cl_Des Cl_From_Des)) {
                my $value = $item->{$key};
                if (ref $value eq 'HASH' and %{$value} == 0) {
                    delete $item->{$key};
                }
            }
            if ($item->{PackCode} eq $number) {
                delete $item->{PackCode};
            }
        }
    }
    dump_yaml($data);
    return;
}

sub carrier::_paczkawruchu
{
    goto &carrier::orlen;
}

sub carrier::poczta
{
    my ($ident) = @_;
    $ident =~ /\A[[:alnum:]]+\z/a or
        fatal('poczta: bad ID format');
    useca('Certum_Trusted_Network_CA');
    my $api_endpoint = 'https://uss.poczta-polska.pl/uss/v1.0/tracking';
    my $url = "https://emonitoring.poczta-polska.pl/?numer=$ident";
    $_ = urlget($url);
    m{<div id="widgetTracking" data-urltracking="\Q$api_endpoint\E" data-apikey="([\w+/.=]+)"/>}
        or die "<$url>: cannot extract API key";
    my $api_key = $1;
    $url = "$api_endpoint/checkmailex";
    my $data = qq({"language":"PL","number":"$ident","addPostOfficeInfo":true});
    my $args = {
        headers => {
            'API_KEY' => $api_key,
            'Content-Type' => 'application/json; charset=utf-8',
        }
    };
    $data = urlget($url, $data, $args);
    $data = $jp->decode($data);
    my $clean_office = sub {
        my ($office, %opts) = @_;
        my $descr = $office->{description};
        $opts{keep_hours} or
            delete $descr->{openingHours};
        if (($descr->{latitude} // 0) == 0 and ($descr->{longitude} // 0) == 0) {
            # 0°N 0°E is in the ocean: https://en.wikipedia.org/wiki/Null_Island
            # It can't possibly be the correct location of a post office.
            delete $descr->{latitude};
            delete $descr->{longitude};
        }
    };
    my $mailinfo = $data->{mailInfo};
    for my $key (keys %{$data}) {
        if ($key ne 'mailInfo') {
            $mailinfo->{$key} = $data->{$key};
        }
    }
    $data = $mailinfo;
    $clean_office->($data->{dispatchPostOffice});
    $clean_office->($data->{recipientPostOffice}, keep_hours => 1);
    for my $item (@{$data->{events}}) {
        for my $key (qw(finished canceled)) {
            if (exists $item->{$key} and JSON::PP::is_bool($item->{$key}) and not $item->{$key}) {
                delete $item->{$key};
            }
        }
        if (exists $item->{postOffice}) {
            $clean_office->($item->{postOffice});
        }
    }
    dump_yaml($data);
    return;
}

sub carrier::_poczta_polska
{
    goto &carrier::poczta;
}

sub carrier::pointpack
{
    my ($ident) = @_;
    $ident =~ /\A\d+\z/a or
        fatal('pointpack: bad ID format');
    useca('Certum_Trusted_Network_CA');
    my $url = "https://www.pointpack.pl/rest/api/v1/tracking/$ident";
    my $data = urlget($url);
    $data = $jp->decode($data);
    for my $item (@{$data}) {
        my $date = $item->{date};
        $date = Time::Piece::localtime($date / 1000);
        $item->{date} = $date->datetime;
        if (not defined $item->{notes}) {
            delete $item->{notes};
        }
    }
    dump_yaml($data);
    return;
}

sub carrier::poltraf
{
    my ($ident) = @_;
    $ident =~ /\A\d+\z/a or
        fatal('poltraf: bad ID format');
    useca('Certum_Trusted_Network_CA');
    $_ = urlget("https://poltraf.pl/zarzadzanie_przesylkami.html?go=ok&nr_przesylki=$ident");
    m{<tbody\b[>]*>(.*?)</tbody>}s or die;
    $_ = $1;
    s{\s*</t[dr]>\s*}{}g;
    s{\s+}{ }g;
    s{\s*<td>}{\t}g;
    s{\s*<tr\b[^>]*>\t}{\n}g;
    s{\A\n+}{};
    say;
    return;
}

my %carriers;
my @carrier_names;
for my $cname (sort keys %carrier::) {
    my $func = $carrier::{$cname};
    if (not $cname =~ s/\A_//) {
        push @carrier_names, $cname;
    }
    $carriers{$cname} = $func;
}
my $usage = <<"EOF";
Usage: $prog CARRIER IDENT
Carriers: @carrier_names
EOF
sub bad_usage
{
    print {*STDERR} $usage;
    exit 1;
}
if (@ARGV == 1 and grep { $ARGV[0] eq $_ } qw(-h --help)) {
    print $usage;
    exit 0;
}
if (@ARGV != 2) {
    bad_usage;
}
my ($cname, $ident) = @ARGV;
$cname =~ s/-/_/g;
if (my $action = $carriers{$cname}) {
    $action->($ident);
} else {
    bad_usage;
}

# vim:ts=4 sts=4 sw=4 et
